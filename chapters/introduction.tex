\section{Incipit}

In un modello relazionale, la scoperta delle dipendenza funzionali assume un ruolo importante durante la progettazione o normalizzazione. Già da molto queste dipendenze vengono utilizzate per migliorare la qualità dei database.
Negli ultimi anni abbiamo visto aumentare le fonti che generano dati, sia provenienti dal web, dalle reti di sensori, da reti biologiche. All’aumento della quantità di dati generata non è corrisposto un mantenimento della stessa qualità. Ovviamente con moli di dati elevate è inconcepibile tentare di effettuare un cleaning dei dati manualmente.In quest’ottica è però possibile utilizzare le dipendenze funzionali approssimate(AFD o RFD) \footnote{In tutta la tesi Dipendenze Funzionali Approssimate e Dipendenze Funzionali Rilassate indicano lo stesso concetto.} per catturare delle consistenze più ampie nei dati.
Una volta individuate, queste RFD possono essere utilizzate sia in data cleaning, sia in sistemi di query approssimate. Durante il lavoro di tesi si è focalizzato sul rilassamento delle interrogazioni. Nei sistemi di query sorgono problemi quando effettuata l'interrogazione viene restituita una risposta vuota o non soddisfacente. In questi casi potrebbero interessare non solo gli elementi che combaciano esattamente con la query , ma anche quelli simili, se però possiedono qualche legame con la query. Qualsiasi motore di ricerca utilizza già un sistema per allargare il Result Set \footnote{Per Result Set si intende l'insieme di tuple (o risultati) restituiti da un interrogazione.}, basta infatti allargare i range di ricerca per ottenere un Result Set più ampio. Spesso però includere risultati che differiscono molto da ciò che cerchiamo non è utile, in questo caso sarebbe preferibile effettuare una nuova ricerca con parametri differenti che però restituisca dei risultati attinenti a ciò che viene cercato inizialmente. Come si può effettuare questa cosa? Esiste qualche funzione che suggerisca cosa cercare quando su Amazon scrivendo "PC Gaming Dell" non escono risultati soddisfacenti? Ebbene si, un modo c'è! Implementando questa tecnica si può ricevere un suggerimento di ricerca come "I7 gtx 1080 SSD 256". Questo tipo di sistema è in grado di capire che chi è interessato ad un Computer da Gaming della Dell probabilmente sarà attratto anche da un computer che possiede un processore i7, una scheda video gtx 1080 ed una SSD .
Questo link fra "PC Gaming Dell" e "I7 gtx 1080 SSD 256" viene dato dalle RFD.

\section{Utilizzo delle FD in contesti particolari}

In alcuni contesti non è possibile utilizzare le FD canoniche, in quanto il concetto di uguaglianza non esiste. In questi casi vengono applicati delle funzioni di similarità ad-hoc. Gli esempi più banali cominciano dalle stringhe , dove per misurare la differenza fra due di esse si usa la Distanza di Levenshtein\footnote{La distanza di Levenshtein è una misura per la differenza di stringhe, dove si tiene conto lettere mancanti, sbagliate o superflue.}, o dalla data  dove per effettuare un confronto bisogna implementare il calendario gregoriano. In alcuni ambiti invece le funzioni di similarità aumentano di complessità, si pensi a come può essere strutturata una funzione di similarità in un sistema multimediale. In molti casi è opportuno implementare una fonte di conoscenza esterna, come ad esempio in un database riguardante le città europee dove conviene utilizzare una funzione che ne misuri la distanza spaziale piuttosto che la somiglianza lessicale. Le FD canoniche non ammettono l'esistenza di un funzione di similarità, in questo caso si preferiscono utilizzare le RFD.

\section{Ricerca di RFD}
Gli algoritmi di ricerca delle RFD o AFD hanno complessità elevata dato lo spazio di ricerca dei possibili vincoli di similarità, la complessità è riconducibile al problema di trovare un insieme ricoprente minimale di RFD verificate per una relazione $r$. Ciò al momento pone un forte fardello sullo sviluppo di software che sfrutta le RFD. Con database che superano le migliaia di righe è ancora impossibile l’approccio. In questo lavoro di tesi non sono stati utilizzati DataSet troppo ampi in quanto il tempo richiesto per generare le RFD era spropositato. Al momento vi sono alcuni team che stanno lavorando sulla parallelizzazione dell'algoritmo di ricerca, si sono già ottenuti ottimi risultati durante la fase di testing, si è arrivati ad ottenere un aumento delle performance pari al 75\%.


\section{Studi Preliminari}
Prima di cominciare il lavoro relativo al sistema di Query Relaxation è stato necessario studiare il linguaggio Python.
La scelta è ricaduta su Python per tre motivi principali:
\begin{enumerate}
    \item È un linguaggio che seppur orientato agli oggetti, possiede delle librerie quali: Cython, ecc.. le quali permettono di aumentare la velocità eseguendo il codice in C.
    \item Il sistema esistente di discovery di RFD è stato sviluppato in Python, ed anche se il nostro modulo ne è indipendente, si è preferito utilizzare lo stesso linguaggio.
    \item Per ampliare le competenze, possedere un progetto sviluppato in Python .
\end{enumerate}
Oltre le principali tecniche di programmazione sono stati utilizzati alcune particolari funzionalità del Python:

\begin{itemize}
\item List Comprehensions: Uno strumento che permette di creare in modo conciso e conveniente delle liste partendo da una sequenza di valori esistenti, inoltre le comprehension permettono anche di filtrare e trasformare gli elementi tramite costrutti if.
Normalmente per creare delle liste si procede in questo modo:
\begin{listing}[H]
\begin{minted}[frame=lines,linenos]{python}
newList = []
for i in oldList:
    if filter(i):
        newList.append(expressions(i))
\end{minted}
\end{listing}

Grazie alle List Comprehension il tutto si riduce ad un riga di codice:
\mint{python}|newList = [expression(i) for i in oldList if filter(i)]|

\item Lambda Functions: Python supporta la crezione di funzioni anonime \footnote{Ossia funzioni che non sono legate ad un nome} a runtime , usando dei costrutti chiamati "lambda".  
\begin{listing}[H]
\begin{minted}[frame=lines,linenos]{python}
# Esempio di utilizzo delle lambda functions

double = lambda x: x * 2

# Output: 10
print(double(5))
\end{minted}
\end{listing}
\item Negative Indexing: Per ottenere un elemento da una lista è possibile utilizzare degli indici negativi ottenendo (in una lista di k elementi) il (k-n)esimo elemento
\begin{listing}[H]
\begin{minted}[frame=lines,linenos]{python}
>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> a[-1]
10
\end{minted}
\end{listing}
\item Iterazione su chiave-valore: è possibile iterare sui dizionari ottenendo contemporaneamente chiave e valore.
\begin{listing}[H]
\begin{minted}[frame=lines,linenos]{python}
>>> m = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
>>> for k, v in m.iteritems():
...     print '{}: {}'.format(k, v)
...
a: 1
c: 3
\end{minted}
\end{listing}


\end{itemize}


Oltre le librerie standard sono stati utilizzati alcuni Framework esterni: 
\begin{itemize}
\item Pandas: È una libreria che include delle strutture dati e tool di analisi facili da usare e fortemente ottimizzate. 
\item Numpy : È un package dedicato all'elaborazione scientifica sul linguaggio Python.
\end{itemize}
All'infuori delle conoscenze legate ai linguaggi di programmazione , è stato necessario leggere e studiare vari documenti legati al mondo delle dipendenze funzionali. La maggior parte del tempo è stata impiegata per capire in che modo utilizzare le RFD. 
È stato necessario comprendere il funzionamento(visione black-box) dell’algoritmo utilizzato nel progetto di IA. 

\section{Dipendenze funzionali rilassate}
Prima di esporre le RFD è necessario introdurre alcune notazioni preliminari.

\subsection{Schema di relazione}
Uno schema di relazione è costituito da un simbolo $R$, detto nome della relazione, e da un insieme di attributi $X = \{A_1,A_2,...,A_n\}$, di solito indicato
con $R(X)$. A ciascun attributo $A \in X$ e associato un dominio $dom(A)$.
Uno schema di base di dati è un insieme di schemi di relazione con nomi
diversi:
\\~\\
\centerline{$R = \{ R_1(X_1),R_2(X_2),\ldots,R_n(X_n)\}$.}
\\~\\
Una relazione su uno schema $R(X)$ è un insieme $r$ di tuple su $X$. Per
ogni istanza $r \in R(X)$, per ogni tupla $t \in r$ e per ogni attributo $A \in X$,
$t[A]$ rappresenta la proiezione di $A$ su $t$. In modo analogo, dato un insieme
di attributi $Y \subseteq X$, $t[Y]$ rappresenta la proiezione di $Y$ su $t$.\cite{libroCeri}


\begin{table}[H]
    \centering
    \begin{tabular}{ | l | l | l | l |}
        \hline
        Matricola & Cognome & Nome & Data di nascita\\
        \hline
        276545 & Rossi & Maria & 25/11/1991 \\ 
        485745 & Neri & Anna & 23/04/1992 \\ 
        200768 & Verdi & Fabio & 12/02/1992 \\
        587614 & Rossi & Luca & 10/10/1991 \\
        937653 & Bruni & Mario & 01/12/1991 \\
        \hline
    \end{tabular}
    \caption{Esempio di schema di relazione}
    \label{tab:table example}
\end{table}


\subsection{Dipendenze funzionali canoniche}
Data una relazione $r$ su uno schema $R(X)$ e due sottoinsiemi di attributi non vuoti $Y$ e $Z$ di $X$,diremo che esiste su $r$ una dipendenza funzionale\footnote{Il termine Dipendenza Funzionale nella tesi viene spesso abbreviato in FD (Functional Dependency)} tra gli attributi $Y$ e $Z$, se, per ogni coppia di tuple $t_1$ e $t_2$ di $r$ aventi gli stessi valori sugli attributi $U$, risulta che $t_1$ e $t_2$ hanno gli stessi valori anche sugli attributi $Z$.
Generalmente indichiamo una dipendenza funzionale tra gli attributi $Y$ e $Z$ con la notazione $Y->Z$ , ogni FD  viene associata ad uno schema.

Dato che le dipendenza funzionali dovrebbero servire a descrivere proprietà significative della applicazione, è necessario separare dalle dipendenze funzionali le dipendenze funzionali banali.
In generale una dipendenza funzionale $Y->A$ è non banale se $A$ non compare tra gli attributi di $Y$
Un'ultima osservazione va fatta sul legame presente tra il concetto di dipendenza funzionale e il concetto di vincolo di chiave. Possiamo dire che una dipendenza funzionale $Y->Z$ su uno schema $R(X)$ degenera nel vincolo di chiave se l’unione di $Y$ e $Z$ è pari a $X$. In questo caso Y è superchiave per lo schema R(X)
\subsection{Dipendenze funzionali rilassate}
In alcuni casi per risolvere dei problemi in alcuni di domini di applicazioni, come l’identificazione di inconsistenze tra i dati, o la rilevazione di relazioni semantiche fra i dati,  è necessario rilassare la definizione di dipendenza funzionale, introducendo delle approssimazioni nel confronto dei dati. Invece effettuare dei controlli di uguaglianza , si utilizzano dei controlli di similarità .
Inoltre spesso si potrebbe desiderare che una certa dipendenza valga solo su un sottoinsieme di tuple che su tutte.
Per questo motivo sono nate delle dipendenze funzionali che rilassano alcuni dei vincoli delle FD , prendono il nome di Dipendenze Funzionali Rilassate o Approssimate \footnote{RFD abbreviazione di Relaxed Functional Dependency}.
Esistono differenti tipi di RFD, ciascuna di esse rilassa uno o più vincoli delle FD , si possono dividere in due macro aree:
\begin{enumerate}
    \item Confronto di attributi: La funzione di uguaglianza delle FD canoniche viene sostituita da una funzione di similarità , ciò implica che l'AFD deve descrivere una soglia di rilassamento per ogni attributo.
    \item Estensione: Permette che il vincolo non sia valido su tutte le tuple, ma solo su di un sottoinsieme di esse
\end{enumerate}


Le RFD sono utilizzate in attività di:
data cleaning, record matching e di rilassamento delle query.

Le definizione formale di una RFD è la seguente:
\begin{theorem}
Sia $R$ uno schema relazionale definito su di un insieme di attributi finito, e siano $R_1=(A_1,A_2,...,A_k)$ e $R_2=(B_1,B_2,...,B_m)$ due schemi relazionali definiti su $R$. Una RFD $\varphi$ su $R$ viene rappresentata come:
\\~\\
\centerline{$D_{c_1} \times D_{c_2}:(X_1,X_2)_{\Phi_1} \xrightarrow{\Psi\geq\epsilon}(Y_1,Y_2)_{\Phi_2}$}
\\~\\
dove 
\begin{itemize}
\item $\mathbb{D}_{c_1}\times \mathbb{D}_{c_2} = \{(t_1,t_2)\in dom(R_1)\times dom(R_2)|(\bigwedge_{i=1}^{k} c_{1_i}(t_1[A_i])) \bigwedge_{j=1}^{m} c_{2_j}(t_2[B_j])$, dove $c_{1_i}$ e $c_{2_j}$ sono dei predicati sul $dom(A_i)$ e $dom(B_j)$ rispettivamente, utilizzati per filtrare le tuple a cui $\varphi$ va applicata.
$c_{1_i}(t_1[A_i])$ dà vero se il predicato $c_1$, sull'attributo $A_i$ restituisce vero su $t_1$;
\item $X_1,Y_1 \subseteq attr(R_1)$ e $X_2,Y\subseteq attr(R_2)$ tali che $X_1\cap Y_1=0$ e $X_2\cup Y_2=0 $
\item $\Phi_1$($\Phi_2$ rispettivamente) è un insieme di vincoli $\phi[X_1,X_2](\phi[Y_1,Y_2])$ definite sugli attributi di $X_1$ e $X_2(Y_1$ e $Y_2)$. Per qualsiasi coppia di tuple ($t_1,t_2 \in \mathbb{D}_{c_1} \times \mathbb{D}_{c_2}$) il vincolo $\phi[X_1,X_2](\psi[Y_1,Y_2])$ restituisce vero se la similarità fra $t_1$ e $t_2$ sugli attributi $X_1$ e $X_2(Y_1$ e $Y_2)$ concordano con i vincoli specificati da $\phi[X_1,X_2](\phi[Y_1,Y_2])$;
\item $\Psi: dom(X) \times dom(Y)\xrightarrow{}\mathbb{R}$ rappresenta una misura di copertura su $\mathbb{D}_{c_1} \times \mathbb{D}{c_2}$ e indica il numero di tuple che violano o soddisfano $\varphi$
\item $\epsilon$ è la soglia che indica il limite superiore o inferiore per il risultato della misura di copertura;
\end{itemize}
\end{theorem}
Nel lavoro di tesi vengono trattate solo le RFD che rilassano il vincolo di uguaglianza. Data RFD $X \xrightarrow{} Y$ essa vale su una relazione $r$ se e solo se la distanza fra due tuple $t_1$ e $t_2$, i cui valori sui singoli attributi $A_i$ non superano una certa soglia $\beta_i$, è inferiore ad una certa soglia $a_A$ su ogni attributo $A \in X$, allora la distanza fra $t_1$ e $t_2$ su ogni attributo $B \in Y$ è minore di una certa soglia $a_B$.\\
La struttura delle RFD utilizzate è la seguente:
\\~\\
\centerline{$attr_1(\leq soglia_1),\ldots$,$attr_n(\leq soglia_n) \xrightarrow{} RHS$}
\\~\\
Gli attributi che si trovano a sinistra della freccia costituiscono la parte LHS\footnote{Left Hand Size o lato sinistro}, l'attributo che invece si trova dopo la freccia costituisce l'RHS\footnote{Right Hand Size o lato destro}. 
È importante focalizzare l'attenzione su questo concetto in quanto le dipendenze funzionali hanno un verso, ed è quello indicato dalla freccia. Qualsiasi operazione effettuata con le RFD deve sempre tener conto del verso, le RFD non forniscono conoscenza nel verso opposto. Questa non è una proprietà riguardante solo le RFD , bensì riguarda qualsiasi tipo di dipendenza funzionale.
Ad esempio consideriamo la relazione in questa tabella:
\begin{table}[H]
    \centering
    \begin{tabular}{|l |l |l |l |l |}
    \hline
     Impiegato & Stipendio & Progetto & Bilancio & Funzione \\
    \hline
    Rossi & 20000  & Sito web & 2000 & tecnico\\
    Verdi & 35000 & App Mobile & 15000 & progettista\\
    Verdi & 35000 & Server & 15000 & progettista\\
    Neri & 55000 & Server & 15000 & direttore\\
    Neri & 55000 & App Mobile & 15000 & consulente\\
    Neri & 55000 & Sito web & 2000 & consulente\\
    Mori & 48000 & Sito web & 15000 & direttore\\
    Mori & 48000 & Server & 15000 & progettista\\
    Bianchi & 48000 & Server & 15000 & progettista\\
    Bianchi & 48000 & App Mobile & 15000 & direttore\\
    \hline
    \end{tabular}
    \caption{Esempio di Relazione con anomalie}
    \label{tab:relationship_anomalies}
\end{table}
Si può osservare che lo stipendio di ciascun impiegato è unico, quindi in ogni tupla in cui compare lo stesso impiegato verrà riportato lo stesso stipendio. Possiamo dire che esiste una Dipendenza Funzionale: 
$Impiegato \xrightarrow{} Stipendio$. 
Si può fare lo stesso discorso tra gli attributi Progetto e Bilancio, quindi anche qui abbiamo una dipendenza funzionale
$Progetto\xrightarrow{}Bilancio$. 
Non si può dire che di conseguenza vale anche il verso opposto:
\\~\\
\centerline{$Impiegato \xrightarrow{} Stipendio \neq Stipendio \xrightarrow{} Impiegato$} 
\\~\\
Infatti percepiscono 48000 di stipendio sia Mori che Bianchi.\cite{libroCeri}
\section{Software di ricerca di RFD}
Il software sviluppato per funzionare necessita di una lista di RFD, prese in input da file. Nel caso in cui questa lista non sia disponibile, ci si avvale di un algoritmo di ricerca.
Il progetto riguardante la ricerca di RFD è stato sviluppato durante il corso di Intelligenza Artificiale dell’anno 2016/2017.
L’algoritmo per scoprire le RFD è di tipo top-down \footnote{I metodi top-down effettuano una generazione di possibili FD per ogni livello e gradualmente controllano se esse si verificano}.
Inizialmente si genera un grafo di attributi, definito in una struttura a lattice, dove vengono considerati tutti i possibili sottoinsiemi di attributi. Dato uno schema relazionale
\\~\\ \centerline{$R=(A_1,A_2,...,A_n)$} \\~\\abbiamo che :
\begin{itemize}[noitemsep]
\item livello 0: non contiene alcun attributo
\item livello 1: contiene i singleton di ogni attributi
\item livello 2: contiene tutte le possibili coppie di attributi
\item livello \ldots
\item livello n: contiene tutto l’insieme di attributi.
\end{itemize}
Ogni sottoinsieme contenuto in uno di questi livelli è candidato per una possibile RFD.
L’algoritmo parte del livello 0  e per ogni livello controlla, per tutti i sottoinsiemi $X \in L_r$ ,l’esistenza di dipendenze funzionali.
Il funzionamento preciso è definito da:
per ogni $A \in X$ si cerca di controllare se la $FD$  $X\setminus A \xrightarrow{}  A $ vale. Questo tipo di algoritmo ha complessità esponenziale.

Di questo software non ne è stato studiato il funzionamento white-box, bensì si è preferito un approccio black-box focalizzandosi su cosa prende in input e cosa restituisce in output.

\subsection{Input}
Il programma prende in input un Dataset in formato csv.
Il Dataset possiede una prima riga che funge da header, ogni nome di attributo è separato da un carattere speciale \footnote{Solitamente viene utilizzato il simbolo  ;  }
Ogni riga del file csv costituisce una tupla.

\subsection{Output}
Una volta eseguito l’algoritmo di ricerca l’output, ossia le RFD trovate, viene stampato sul terminale. Le RFD sono raggruppate utilizzando come pivot l’attributo che si trova nel lato RHS\footnote{Per RHS si intende il lato destro di una dipendenza funzionale rilassata} della RFD. Il software restituisce le RFD in due formati:
Il primo è sotto forma di Pandas Dataframe:
\begin{table}[h]
    \centering
    \begin{tabular}{l  l  l  l  l }
     RHS & $attr_1$ & $attr_1$ &$attr_{\ldots}$ & $attr_n$ \\
    \hline
    0 & $v_{11}$ & $v_{12}$ & $v_{1\ldots}$ & $v_{1n}$\\
    1 & $v_{21}$ & $v_{22}$ & $v_{2\ldots}$ & $v_{2n}$\\
    $\ldots$ & $v_{\ldots1}$ & $v_{\ldots2}$ & $v_{\ldots}$ & $v_{\ldots n}$\\
    m & $v_{m1}$ & $v_{m2}$ & $v_{m\ldots}$ & $v_{mn}$\\
    \end{tabular}
    \caption{Pandas Dataframe}
    \label{tab:pandas_dataframe}
\end{table}


Mentre il secondo formato ottenuto avviando il programma specificando l’opzione “-human” è in un formato leggibile ma non portabile:
\\~\\
\centerline{$attr_1(\leq soglia_1),attr_2(\leq soglia_2),\ldots,{attr_n}(\leq soglia_n)->RHS(\leq soglia_{rhs})$}
\\~\\
I tempi di esecuzione di questo algoritmo di ricerca sono abbastanza elevati, già con Dataset che superano il migliaio di righe i tempi non si misurano più in ore ma in giorni. Inoltre abbiamo notato che con Dataset costituiti da poche righe ma da molti attributi i tempi di calcolo aumentano esponenzialmente.