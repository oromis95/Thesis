\section{Incipit}

In un modello relazionale, la scoperta dipendenza funzionali assume un ruolo importante durante la progettazione o normalizzazione. Già da molto queste dipendenze vengono utilizzate per migliorare la qualità dei database.
Negli ultimi anni abbiamo visto aumentare le fonti che generano dati, che siano provenienti dal web, dalle reti di sensori, da reti biologiche. All’aumento della quantità di dati generata non è corrisposta un mantenimento della stessa qualità. Ovviamente con moli di dati elevate è inconcepibile tentare di effettuare un cleaning dei dati manualmente.In quest’ottica è però possibile utilizzare le dipendenze funzionali approssimate(AFD) per catturare delle consistenze più ampie nei dati.
Una volta individuate, queste RFD possono essere utilizzate in data cleaning sia in sistemi di query approssimate. Nei sistemi di query sorgono problemi quando effettuata l'interrogazione viene restituita una risposta vuota o non soddisfacente. In questi casi potrebbe interessare non solo gli elementi che combaciano esattamente con la query , ma anche quelli simili, se però possiedono qualche legame con la query. Un modo per effettuare questa operazione è quello di utilizzare una RFD.
Un sistema di Query Relaxation (basato su AFD) ,che non utilizza solo un semplice ampliamento dei range di ricerca , può essere di estrema utilità in un qualsiasi motore di ricerca in quanto riesce a trovare delle associazioni nascoste fra le varie tuple del database.

\section{Utilizzo delle RFD in contesti particolari}

In alcuni contesti non è possibile utilizzare le FD canoniche, in quanto il concetto di uguaglianza non esiste. In questi casi vengono applicati delle funzioni di similarità ad-hoc. Gli esempi più banali cominciano dalle stringhe dove per misurare la differenza fra due di esse si usa la Distanza di Levenshtein, o dalla data  dove per effettuare un confronto bisogna implementare il calendario gregoriano. In alcuni ambiti invece le funzioni di similarità aumentano di complessità, si pensi a come può essere strutturata una funzione di similarità in un sistema multimediale. In molti casi è opportuno implementare una fonte di conoscenza esterna, se ad esempio ad un database riguardante le città europee conviene utilizzare una funzione che ne misuri la distanza. 

\section{Ricerca di RFD}
Gli algoritmi di ricerca delle AFD hanno complessità elevata dato lo spazio di ricerca dei possibili vincoli di similarità, ciò al momento pone un forte fardello sullo sviluppo di software che sfruttano le AFD. Con database che superano le migliaia di righe è ancora impossibile l’approccio. Al momento si sta lavorando su algoritmo che parallelizzare la ricerca.


\section{Studi Preliminari}
Prima di cominciare il lavoro al sistema di Query Relaxation è stato necessario studiare il linguaggio Python.
La scelta è ricaduta su Python per tre motivi principali:
\begin{enumerate}
    \item È un linguaggio che seppur orientato agli oggetti, possiede delle librerie quali: Cython, ecc.. le quali permettono di aumentare la velocità eseguendo il codice in C
    \item Il sistema esistente di discovery di RFD è stato sviluppato in Python, ed anche se il nostro modulo ne è indipendente, si è preferito utilizzare lo stesso linguaggio.
    \item Per ampliare le competenze, possedere un progetto sviluppato in Python 
\end{enumerate}

Oltre Python sono stati utilizzati alcuni Framework: Pandas,Numpy,ecc..
Oltre le conoscenze legate ai linguaggi di programmazione , è stato necessario leggere e studiare vari documenti legati al mondo delle dipendenze funzionali. La maggior parte del tempo è stata impiegata per capire in che modo utilizzare le RFD. 
È stato necessario comprendere il funzionamento(visione black-box) dell’algoritmo utilizzato nel progetto di IA. 

\section{Dipendenze funzionali rilassate}
Prima di esporre le RFD è necessario introdurre alcune notazioni preliminari.

\subsection{Schema di relazione}
Uno schema di relazione è costituito da un simbolo $R$, detto nome della relazione, e da un insieme di attributi $X = \{A_1,A_2,...,A_n\}$, di solito indicato
con $R(X)$. A ciascun attributo $A \in X$ e associato un dominio $dom(A)$.
Uno schema di base di dati è un insieme di schemi di relazione con nomi
diversi:
\\
\\
\centerline{$R = \{ R_1(X_1),R_2(X_2),...,R_n(X_n)\}$.}
\\
\\
Una relazione su uno schema $R(X)$ e un insieme $r$ di tuple su $X$. Per
ogni istanza $r \in R(X)$, per ogni tupla $t \in r$ e per ogni attributo $A \in X$,
$t[A]$ rappresenta la proiezione di $A$ su $t$. In modo analogo, dato un insieme
di attributi $Y \subseteq X$, $t[Y]$ rappresenta la proiezione di $Y$ su $t$.
\subsection{Dipendenze funzionali canoniche}
Data una relazione $r$ su uno schema $R(X)$ e due sottoinsiemi di attributi non vuoti $Y$ e $Z$ di $X$,diremo che esiste su $r$ una dipendenza funzionale tra gli attributi $Y$ e $Z$, se, per ogni coppia di tuple $t_1$ e $t_2$ di $r$ aventi gli stessi valori sugli attributi $U$, risulta che $t_1$ e $t_2$ hanno gli stessi valori anche sugli attributi $Z$.
Generalmente indichiamo una dipendenza funzionale tra gli attributi $Y$ e $Z$ con la notazione $Y->Z$ e viene associata ad uno schema

Dato che le dipendenza funzionali dovrebbero servire a descrivere proprietà significative della applicazione, è necessario separare dalle dipendenze funzionali le dipendenze funzionali banali.
In generale una dipendenza funzionale $Y->A$ è non banale se $A$ non compare tra gli attributi di $Y$
Un'ultima osservazione va fatta sul legame presente tra il concetto di dipendenza funzionale e il concetto di vincolo di chiave. Possiamo dire che una dipendenza funzionale $Y->Z$ su uno schema $R(X)$ degenera nel vincolo di chiave se l’unione di $Y$ e $Z$ è pari a $X$. In questo caso Y è superchiave per lo schema R(X)
\subsection{Dipendenze funzionali rilassate}
In alcuni casi per risolvere dei problemi in alcuni di domini di applicazioni, come l’identificazione di inconsistenze tra i dati, o la rilevazione di relazioni semantiche fra i dati,  è necessario rilassare la definizione di dipendenza funzionale, introducendo delle approssimazioni nel confronto dei dati. Invece effettuare dei controlli di uguaglianza , si utilizzano dei controlli di similarità .
Inoltre spesso si potrebbe desiderare che una certa dipendenza valga solo su un sottoinsieme di tuple che su tutte.
Per questo motivo sono nato delle dipendenze funzionali che rilassano alcuni dei vincoli delle FD , prendono il nome di Dipendenze Funzionali Rilassate o Approssimate RFD.
Esistono differenti tipi di RFD, ciascuna di esse rilassa uno o più vincoli delle FD e si possono dividere in due macro aree:
\begin{enumerate}
    \item Confronto di attributi: la funzione di uguaglianza delle FD canoniche viene sostituita da una funzione di similarità , ciò implica che l'AFD deve descrivere una soglia di rilassamento per ogni attributo.
    \item Estensione: permette che il vincolo non sia valido su tutte le tuple, ma solo su di un sottoinsieme di esse
\end{enumerate}


Le RFD sono utilizzate in attività di:
data cleaning, record matching e di rilassamento delle query.

Le definizione formale di una RFD è la seguente:
\begin{theorem}
Sia $R$ uno schema relazionale definito su di un insieme di attributi finito, e siano $R_1=(A_1,A_2,...,A_k)$ e $R_2=(B_1,B_2,...,B_m)$ due schemi relazionali definiti su $R$. Una RFD $\varphi$ su $R$ viene rappresentata come:
\\
\\
\centerline{$D_{c_1} \times D_{c_2}:(X_1,X_2)_{\Phi_1} \xrightarrow{\Psi\geq\epsilon}(Y_1,Y_2)_{\Phi_2}$}
\\
\\
dove 
\begin{itemize}
\item $\mathbb{D}_{c_1}\times \mathbb{D}_{c_2} = \{(t_1,t_2)\in dom(R_1)\times dom(R_2)|(\bigwedge_{i=1}^{k} c_{1_i}(t_1[A_i])) \bigwedge_{j=1}^{m} c_{2_j}(t_2[B_j])$, dove $c_{1_i}$ e $c_{2_j}$ sono dei predicati sul $dom(A_i)$ e $dom(B_j)$ rispettivamente, utilizzati per filtrare le tuple a cui $\varphi$ va applicata.
$c_{1_i}(t_1[A_i])$ dà vero se il predicato $c_1$, sull'attributo $A_i$ restituisce vero su $t_1$;
\item $X_1,Y_1 \subseteq attr(R_1)$ e $X_2,Y\subseteq attr(R_2)$ tali che $X_1\cap Y_1=0$ e $X_2\cup Y_2=0 $
\item $\Phi_1$($\Phi_2$ rispettivamente) è un insieme di vincoli $\phi[X_1,X_2](\phi[Y_1,Y_2])$ definite sugli attributi di $X_1$ e $X_2(Y_1$ e $Y_2)$. Per qualsiasi coppia di tuple ($t_1,t_2 \in \mathbb{D}_{c_1} \times \mathbb{D}_{c_2}$) il vincolo $\phi[X_1,X_2](\psi[Y_1,Y_2])$ restituisce vero se la similarità fra $t_1$ e $t_2$ sugli attributi $X_1$ e $X_2(Y_1$ e $Y_2)$ concordano con i vincoli specificati da $\phi[X_1,X_2](\phi[Y_1,Y_2])$;
\item $\Psi: dom(X) \times dom(Y)\xrightarrow{}\mathbb{R}$ rappresenta una misura di copertura su $\mathbb{D}_{c_1} \times \mathbb{D}{c_2}$ e indica il numero di tuple che violano o soddisfano $\varphi$
\item $\epsilon$ è la soglia che indica il limite superiore o inferiore per il risultato della misura di copertura;
\end{itemize}
\end{theorem}

Nel lavoro di tesi vengono trattate solo le RFD che rilassano il vincolo di uguaglianza. Data RFD $X \xrightarrow{} Y$ essa vale su una relazione $r$ se e solo se la distanza fra due tuple $t_1$ e $t_2$, i cui valori sui singoli attributi $A_i$ non superano una certa soglia $\beta_i$, è inferiore ad una certa soglia $a_A$ su ogni attributo $A \in X$, allora la distanza fra $t_1$ e $t_2$ su ogni attributo $B \in Y$ è minore di una certa soglia $a_B$ 



\section{Software di ricerca di RFD}
Aliquam eu diam dignissim eros sagittis ultrices. Sed eu laoreet lacus. Duis odio turpis, iaculis et nisl eu, tempor interdum eros. Vivamus cursus condimentum quam sit amet tristique. Nulla facilisi. Curabitur nibh sem, suscipit et pretium vitae, efficitur at sem. Praesent nunc est, malesuada a rhoncus vel, tincidunt a ligula. Cras ullamcorper lectus vel blandit lobortis. Nullam quis ipsum luctus, porta dui ut, ornare arcu.

Aliquam ante odio, egestas id elit eu, condimentum faucibus metus. Morbi sollicitudin eu diam non vestibulum. Nullam vel massa odio. Maecenas ornare, neque eget auctor finibus, nulla nunc vehicula enim, et posuere purus metus quis libero. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Morbi tempus sit amet nibh eu luctus. In ipsum ipsum, pellentesque nec suscipit ut, vehicula euismod magna. Donec cursus ipsum id urna vulputate faucibus. Maecenas sollicitudin ante a lacinia facilisis. Fusce tincidunt neque non est suscipit, vel consequat magna varius. Sed pharetra, eros a luctus finibus, nunc urna bibendum libero, non malesuada massa urna eu tortor.